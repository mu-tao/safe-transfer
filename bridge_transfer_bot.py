import os
import json
import discord
from discord.ext import commands
import logging
from binascii import unhexlify
import bittensor as bt
from tabulate import tabulate


# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Create a dictionary to act as a simple persistent database
database = {}
arbitration = {}

# Load the database from a file if it exists
def load_database():
    if os.path.exists('database.json'):
        with open('database.json', 'r') as db_file:
            return json.load(db_file)
    return {}

# Save the database to a file
def save_database():
    with open('database.json', 'w') as db_file:
        json.dump(database, db_file, indent=4)
        
# Load the database from a file if it exists
def load_arbitration():
    if os.path.exists('arbitration.json'):
        with open('arbitration.json', 'r') as db_file:
            return json.load(db_file)
    return {}

# Save the database to a file
def save_arbitration():
    with open('arbitration.json', 'w') as db_file:
        json.dump(arbitration, db_file, indent=4)

# Verify the transaction data
def verify_transaction(transaction_data):
    try:
        keypair = bt.Keypair(transaction_data['coldkey_ss58'])
        if not keypair.verify(transaction_data['extrinsic_data'], unhexlify(transaction_data['signature'].encode())):
            return False, 'Signature verification failed.'
        return True, None
    except Exception as e:
        return False, f'Error during verification: {e}'

    
async def handle_help(message):
    help_message = (
        "# Help Menu\n"
        "\n\n"
        "## Instructions:\n"
        "1. Send a DM with an ***attached transaction file*** it MUST be the ***file*** generated by the safe_transfer.py script found here: (https://github.com/opentensor/safe-transfer)\n"
        " - It ***MUST*** be a file (generated by the script)\n"
        " - You can attach the file by pressing the + in the bottom left hand corner of this chat.\n"
        "2. Use the **/list** command to see a list of your extrinsics one per coldkey with corresponding extrinsic snippets.\n"
        "\n\n"
        
        "## About the transaction you are sending us:\n"
        "1. The transaction is ***SubtensorModule::unstake_all_and_transfer_to_new_coldkey*** which unstakes all your funds from all your associated hotkeys and sends them to the address you specified.\n"
        "2. The transaction you are sending us is ***signed by you*** and will be submitted to the chain as usual after being tunneled through the firewall\n"
        "3. We cannot edit this transaction. \n"
        "4. We will not share this transaction with anyone not affiliated with the OTF team and only as a means to arbitrate the transaction\n"
        "5. We will delete the transaction details as soon as they have been sent to the chain. \n"
        "\n\n"

        "## Things to know:\n"
        "1. If you add new extrinsics with the same coldkey the bot will replace the old extrinsic with the new one.\n"
        "2. If someone else submits a transaction here which is also signed by your coldkey, we will need to arbitrate the transaction.\n"
        "3. This bot will notify you when your transaction has been tunneled through to the chain and if it is successful.\n"
        "4. We will tunnel all transaction to the chain after X days where X will be announced in the Bittensor annoucements channel.\n"
        "5. If we cannot properly arbitrate your transaction we will simply not send them to the chain.\n"
        "6. If you have any questions or feedback about this bot please reach out to us on the Bittensor discord at https://discord.gg/bittensor general channel.\n"
    )
    # await message.channel.send(f"```markdown\n{help_message}\n```")
    await message.channel.send(help_message)
    logger.info('Help message sent.')
    
async def handle_list(message):
    user_UID = str(message.author.id)
    if user_UID not in database:
        await message.channel.send('No transaction data found for your username')
        logger.info('No transaction data found for user.')
        return
    else:
        user_transactions = database[user_UID]
        if not user_transactions:
            await message.channel.send('No transactions found.')
            return
        # Prepare data for tabulate
        headers = ["From", "To", "Hash"]
        rows = [
            [data['coldkey_ss58'], data['new_wallet_address']]
            for data in user_transactions
        ]

        # Generate table using tabulate
        table = tabulate(rows, headers=headers, tablefmt="discord")
        await message.channel.send(f'Transfer All:\n```markdown\n{table}\n```')
                
async def handle_transaction_file(message):
    
    # Get user metadata.
    user_name = str(message.author)
    user_id = str(message.author.id)
    user_discriminator = str(message.author.discriminator)
    user_display_name = str(message.author.display_name)
    message_id = str(message.id)
    message_timestamp = str(message.created_at.isoformat())
    attachment = message.attachments[0]
    user_UID = str(message.author.id)
    
    # Download and load the tmp file.
    os.makedirs('transactions', exist_ok=True)    
    tmp_file_path = f'transactions/tmp.json'
    await attachment.save(tmp_file_path)
    logger.info(f'Saved tmp file to {tmp_file_path}')
    with open(tmp_file_path, 'r') as file:
        new_transaction_data = json.loads(file.read())
        
    # Add additional info to the transaction.
    new_transaction_data.update({
        'user_name': user_name,
        'user_id': user_id,
        'user_UID': user_UID,
        'user_display_name': user_display_name,
        'message_id': message_id,
        'message_timestamp': message_timestamp
    })
    logger.info(f'New transaction data: {new_transaction_data}')

    # Perform verification on the new transaction.
    is_valid, error_message = verify_transaction(new_transaction_data)
    if not is_valid:
        await message.channel.send(f'Error: {error_message}')
        logger.error(error_message)
        return
    
    # Check if the transaction is in arbitration
    arbitration_key = new_transaction_data['coldkey_ss58']
    if arbitration_key in arbitration:
        await message.channel.send('Error: This transaction is currently in arbitration with another user.')
        logger.warning('Transaction is in arbitration with another user.')
        return
    
    # Check for duplicate coldkey_ss58 address for the same user and remove it
    did_replace = False
    user_transactions = database.get(user_UID, [])
    user_transactions = []
    for old_transaction in user_transactions:
        if old_transaction['coldkey_ss58'] != new_transaction_data['coldkey_ss58']:
            user_transactions.append(old_transaction)
        else:
            replaced_transaction = old_transaction
            did_replace = True
        
    # Check for duplicate coldkey_ss58 address for different users
    for other_user_UID, other_user_transactions in database.items():
        if other_user_UID != user_UID:  # Ensure we are not checking the same user
            for other_old_transaction in other_user_transactions:
                if other_old_transaction['coldkey_ss58'] == new_transaction_data['coldkey_ss58']:
                    # Add both transactions to the arbitration database
                    arbitration_key = new_transaction_data['coldkey_ss58']
                    arbitration.setdefault(arbitration_key, []).append(new_transaction_data)
                    arbitration[arbitration_key].append(other_old_transaction)
                    
                    # Remove the arbitrated transaction from both users' transactions
                    user_transactions = [t for t in user_transactions if t['coldkey_ss58'] != new_transaction_data['coldkey_ss58']]
                    other_user_transactions = [t for t in other_user_transactions if t['coldkey_ss58'] != new_transaction_data['coldkey_ss58']]
                    database[user_UID] = user_transactions
                    database[other_user_UID] = other_user_transactions
                    save_database()
                    save_arbitration()
                    
                    await message.channel.send('Error: A different user has already submitted a transaction with the same coldkey_ss58 address. We need to arbitrate this transaction.')
                    logger.warning('Duplicate coldkey_ss58 address found for different users. Added to arbitration database.')
                    return
            
    # Add the transaction to the user's list of transactions
    user_transactions.append(new_transaction_data)
    database[ user_UID ] = user_transactions
    save_database()
    logger.info('Database updated.')
    extrinsic_hash = new_transaction_data['hash']
    extrinsic_details = f"{extrinsic_hash[:5]}...{extrinsic_hash[-5:]}"
    if did_replace:
        await message.channel.send(f'Replaced an old transaction with coldkey: {replaced_transaction["coldkey_ss58"]}')
        logger.info(f'Replaced old transaction: {replaced_transaction}')
    else:
        await message.channel.send(f"Added\n\tFrom: {new_transaction_data['coldkey_ss58']}\n\tTo: {new_transaction_data['new_wallet_address']}")
        logger.info(f'New transaction: {extrinsic_details}')
        
    # Print the new table.
    help_message = (
        "### Next Steps\n"
        " 1. Wait X days for OTF to collect everyones transactions.\n"
        " 2. We will notify you if your transfer has been tunneled, failed, or requires arbitration.\n"
        " 3. If you have any questions, please reach out to @moderators on the Bittensor discord at https://discord.gg/bittensor general channel.\n"
    )
    await message.channel.send(help_message)
    await handle_list(message)

# Handle incoming messages
async def handle_message(message):
    logger.info(f'Message: {message}')
    if message.content == '/help':
        await handle_help(message)
    elif message.content == '/list':
        await handle_list(message)
    elif isinstance(message.channel, discord.DMChannel) and message.attachments:
        await handle_transaction_file(message)
    else:
        await bot.process_commands(message)

# Create a bot instance
intents = discord.Intents.default()
intents.message_content = True
intents.messages = True
intents.guilds = True
intents.dm_messages = True
bot = commands.Bot(command_prefix='!', intents=intents)

@bot.event
async def on_ready():
    logger.info(f'Logged in as {bot.user}')

@bot.event
async def on_message(message):
    logger.info(message)
    await handle_message(message)

# Load the database
database = load_database()
logger.info('Database loaded.')

# Load the arbitration
arbitration = load_arbitration()
logger.info('Arbitration loaded.')

# Run the bot with your token
bot.run(os.getenv('DISCORD_BOT_TOKEN'))
logger.info('Bot started.')

